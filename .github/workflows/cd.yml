name: Continuous Deployment

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and push Docker images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}

    # Build and push API image
    - name: Build and push API image
      id: build-api
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.api
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${{ github.sha }},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:latest
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

    # Build and push Worker image
    - name: Build and push Worker image
      id: build-worker
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.worker
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/worker:${{ github.sha }},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/worker:latest
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

    # Build and push Web image
    - name: Build and push Web image
      id: build-web
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.web
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/web:${{ github.sha }},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/web:latest
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

    # Build and push Mobile image (Flutter web + APK)
    - name: Build and push Mobile image
      id: build-mobile
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.mobile
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mobile:${{ github.sha }},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mobile:latest
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    # Sign the container images with cosign
    - name: Install cosign
      if: github.event_name != 'pull_request'
      uses: sigstore/cosign-installer@v3.1.1

    - name: Sign container images
      if: github.event_name != 'pull_request'
      env:
        COSIGN_EXPERIMENTAL: 1
      run: |
        cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${{ github.sha }}
        cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/worker:${{ github.sha }}
        cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/web:${{ github.sha }}
        cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/mobile:${{ github.sha }}

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging.landscaping-app.com
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.STAGING_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.STAGING_AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Deploy to ECS (Staging)
      run: |
        # Update ECS task definition with new image
        aws ecs update-service \
          --cluster landscaping-staging \
          --service landscaping-api \
          --force-new-deployment
        
        aws ecs update-service \
          --cluster landscaping-staging \
          --service landscaping-worker \
          --force-new-deployment
        
        aws ecs update-service \
          --cluster landscaping-staging \
          --service landscaping-web \
          --force-new-deployment

    - name: Wait for deployment completion
      run: |
        aws ecs wait services-stable \
          --cluster landscaping-staging \
          --services landscaping-api landscaping-worker landscaping-web

    - name: Run database migrations (staging)
      run: |
        # Run migrations using ECS task
        aws ecs run-task \
          --cluster landscaping-staging \
          --task-definition landscaping-migrate:latest \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[subnet-xxx],securityGroups=[sg-xxx],assignPublicIp=ENABLED}"

    - name: Health check
      run: |
        timeout=300
        start_time=$(date +%s)
        
        while true; do
          current_time=$(date +%s)
          elapsed=$((current_time - start_time))
          
          if [ $elapsed -gt $timeout ]; then
            echo "Health check timeout"
            exit 1
          fi
          
          if curl -f https://staging-api.landscaping-app.com/health; then
            echo "Staging deployment successful"
            break
          fi
          
          echo "Waiting for service to be healthy..."
          sleep 10
        done

    - name: Run smoke tests
      run: |
        cd tests/smoke
        npm install
        npm run test:staging

    - name: Notify deployment status
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        text: |
          Staging deployment ${{ job.status }}
          Repository: ${{ github.repository }}
          Commit: ${{ github.sha }}
          Environment: staging
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    if: startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment:
      name: production
      url: https://landscaping-app.com
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.PROD_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.PROD_AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Create backup before deployment
      run: |
        # Create database backup
        aws rds create-db-snapshot \
          --db-instance-identifier landscaping-prod \
          --db-snapshot-identifier landscaping-prod-pre-deploy-$(date +%Y%m%d-%H%M%S)

    - name: Blue-Green Deployment Setup
      run: |
        # Create new task definitions with updated images
        ./deployment/scripts/update-task-definitions.sh production ${{ github.sha }}

    - name: Deploy to Production (Blue-Green)
      run: |
        # Deploy new version to green environment
        ./deployment/scripts/deploy-blue-green.sh production

    - name: Run database migrations (production)
      run: |
        # Run migrations using ECS task
        aws ecs run-task \
          --cluster landscaping-prod \
          --task-definition landscaping-migrate:latest \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[subnet-xxx],securityGroups=[sg-xxx],assignPublicIp=DISABLED}"

    - name: Health check (Production)
      run: |
        timeout=600
        start_time=$(date +%s)
        
        while true; do
          current_time=$(date +%s)
          elapsed=$((current_time - start_time))
          
          if [ $elapsed -gt $timeout ]; then
            echo "Health check timeout"
            exit 1
          fi
          
          if curl -f https://api.landscaping-app.com/health; then
            echo "Production deployment successful"
            break
          fi
          
          echo "Waiting for service to be healthy..."
          sleep 15
        done

    - name: Run production smoke tests
      run: |
        cd tests/smoke
        npm install
        npm run test:production

    - name: Switch traffic to green environment
      run: |
        # Update load balancer to point to green environment
        ./deployment/scripts/switch-traffic.sh production

    - name: Final health check
      run: |
        sleep 30
        curl -f https://api.landscaping-app.com/health
        curl -f https://landscaping-app.com/health

    - name: Cleanup old blue environment
      run: |
        # Scale down old blue environment
        ./deployment/scripts/cleanup-blue.sh production

    - name: Update deployment status
      run: |
        # Update deployment tracking
        echo "Production deployment completed at $(date)" >> deployment-log.txt

    - name: Notify deployment status
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        text: |
          🚀 Production deployment ${{ job.status }}!
          Repository: ${{ github.repository }}
          Version: ${{ github.ref_name }}
          Commit: ${{ github.sha }}
          Environment: production
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Deploy to Google Cloud Run (alternative deployment)
  deploy-gcp:
    name: Deploy to Google Cloud Run
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'gcp'
    environment:
      name: gcp-production
      url: https://landscaping-app.com
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    - name: Configure Docker for GCR
      run: gcloud auth configure-docker

    - name: Deploy API to Cloud Run
      run: |
        gcloud run deploy landscaping-api \
          --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api:${{ github.sha }} \
          --platform managed \
          --region us-central1 \
          --allow-unauthenticated \
          --set-env-vars ENV=production \
          --memory 1Gi \
          --cpu 1 \
          --max-instances 10

    - name: Deploy Worker to Cloud Run
      run: |
        gcloud run deploy landscaping-worker \
          --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/worker:${{ github.sha }} \
          --platform managed \
          --region us-central1 \
          --no-allow-unauthenticated \
          --set-env-vars ENV=production \
          --memory 1Gi \
          --cpu 1 \
          --max-instances 5

    - name: Deploy Web to Cloud Run
      run: |
        gcloud run deploy landscaping-web \
          --image ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/web:${{ github.sha }} \
          --platform managed \
          --region us-central1 \
          --allow-unauthenticated \
          --set-env-vars ENV=production \
          --memory 512Mi \
          --cpu 1 \
          --max-instances 10

    - name: Update Cloud Load Balancer
      run: |
        # Update load balancer backend services
        gcloud compute backend-services update landscaping-api-backend \
          --global

  # Rollback workflow
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && (contains(github.event_name, 'workflow_dispatch') || contains(github.ref, 'refs/tags/'))
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.PROD_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.PROD_AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Rollback to previous version
      run: |
        # Get previous stable task definition
        ./deployment/scripts/rollback.sh production

    - name: Verify rollback
      run: |
        sleep 60
        curl -f https://api.landscaping-app.com/health

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: 'warning'
        channel: '#deployments'
        text: |
          ⚠️ Production rollback completed
          Repository: ${{ github.repository }}
          Commit: ${{ github.sha }}
          Reason: Deployment failure
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}