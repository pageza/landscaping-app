package integrations

import (
	"context"
	"time"

	"github.com/google/uuid"

	// TODO: Re-enable reusable packages after fixing availability
	// "github.com/pageza/go-storage" // Temporarily commented to break import cycle
	// "github.com/pageza/go-llm"
	// "github.com/pageza/go-payments"
	// "github.com/pageza/go-comms"

	"github.com/pageza/landscaping-app/backend/internal/config"
	"github.com/pageza/landscaping-app/backend/internal/domain"
)

// IntegrationManager manages all external integrations
type IntegrationManager struct {
	config          *config.Config
	// storage         *storage.Client // TODO: Re-enable after fixing import cycle
	llm             *LLMIntegration
	payments        *PaymentsIntegration
	communications  *CommsIntegration
	
	// External API clients
	weatherAPI      WeatherAPI
	mapsAPI         MapsAPI
	calendarAPI     CalendarAPI
	
	// Internal services
	webhookService  WebhookService
	auditService    AuditService
}

// NewIntegrationManager creates a new integration manager
func NewIntegrationManager(cfg *config.Config) (*IntegrationManager, error) {
	// TODO: Re-enable storage client after fixing import cycle
	/*
	storageClient, err := storage.New(&storage.Config{
		Provider:    cfg.StorageProvider,
		Bucket:      cfg.StorageBucket,
		Region:      cfg.StorageRegion,
		AccessKey:   cfg.StorageAccessKey,
		SecretKey:   cfg.StorageSecretKey,
		Endpoint:    cfg.StorageEndpoint,
		PublicURL:   cfg.StoragePublicURL,
	})
	if err != nil {
		return nil, err
	}
	*/

	llmClient, err := llm.New(&llm.Config{
		OpenAIAPIKey:      cfg.OpenAIAPIKey,
		AnthropicAPIKey:   cfg.AnthropicAPIKey,
		DefaultProvider:   cfg.DefaultLLMProvider,
	})
	if err != nil {
		return nil, err
	}

	paymentsClient, err := payments.New(&payments.Config{
		StripePublicKey:    cfg.StripePublicKey,
		StripeSecretKey:    cfg.StripeSecretKey,
		StripeWebhookSecret: cfg.StripeWebhookSecret,
	})
	if err != nil {
		return nil, err
	}

	commsClient, err := comms.New(&comms.Config{
		SMTPHost:     cfg.SMTPHost,
		SMTPPort:     cfg.SMTPPort,
		SMTPUsername: cfg.SMTPUsername,
		SMTPPassword: cfg.SMTPPassword,
		SMTPFromEmail: cfg.SMTPFromEmail,
		SMTPFromName:  cfg.SMTPFromName,
	})
	if err != nil {
		return nil, err
	}

	// Initialize external API clients
	weatherAPI := NewWeatherAPI(cfg)
	mapsAPI := NewMapsAPI(cfg)
	calendarAPI := NewCalendarAPI(cfg)

	return &IntegrationManager{
		config:         cfg,
		// storage:        storageClient, // TODO: Re-enable after fixing import cycle
		llm:            llmClient,
		payments:       paymentsClient,
		communications: commsClient,
		weatherAPI:     weatherAPI,
		mapsAPI:        mapsAPI,
		calendarAPI:    calendarAPI,
	}, nil
}

// TODO: Re-enable StorageService after fixing import cycle
/*
type StorageService struct {
	client *storage.Client
}
*/

// Upload uploads a file to storage
func (s *StorageService) Upload(ctx context.Context, path string, data []byte, contentType string) (string, error) {
	return s.client.Upload(ctx, path, data, &storage.UploadOptions{
		ContentType: contentType,
		ACL:         "private", // Default to private
	})
}

// UploadPublic uploads a file with public access
func (s *StorageService) UploadPublic(ctx context.Context, path string, data []byte, contentType string) (string, error) {
	return s.client.Upload(ctx, path, data, &storage.UploadOptions{
		ContentType: contentType,
		ACL:         "public-read",
	})
}

// Download downloads a file from storage
func (s *StorageService) Download(ctx context.Context, path string) ([]byte, error) {
	return s.client.Download(ctx, path)
}

// Delete removes a file from storage
func (s *StorageService) Delete(ctx context.Context, path string) error {
	return s.client.Delete(ctx, path)
}

// GetURL gets a public URL for a file
func (s *StorageService) GetURL(ctx context.Context, path string) (string, error) {
	return s.client.GetURL(ctx, path)
}

// GetSignedURL gets a signed URL for temporary access
func (s *StorageService) GetSignedURL(ctx context.Context, path string, expiry time.Duration) (string, error) {
	return s.client.GetSignedURL(ctx, path, expiry)
}

// LLMService provides AI/ML operations
type LLMService struct {
	client *llm.Client
}

// GenerateText generates text using AI
func (s *LLMService) GenerateText(ctx context.Context, prompt string, options *LLMOptions) (string, error) {
	llmOptions := &llm.GenerateOptions{
		Model:       options.Model,
		MaxTokens:   options.MaxTokens,
		Temperature: options.Temperature,
	}
	return s.client.Generate(ctx, prompt, llmOptions)
}

// AnalyzeImage analyzes an image with AI
func (s *LLMService) AnalyzeImage(ctx context.Context, imageData []byte, prompt string) (string, error) {
	return s.client.AnalyzeImage(ctx, imageData, prompt)
}

// GenerateQuote generates a quote using AI
func (s *LLMService) GenerateQuote(ctx context.Context, req *QuoteGenerationRequest) (*QuoteGenerationResponse, error) {
	// Build comprehensive prompt for quote generation
	prompt := s.buildQuotePrompt(req)
	
	response, err := s.client.Generate(ctx, prompt, &llm.GenerateOptions{
		Model:       "gpt-4",
		MaxTokens:   2000,
		Temperature: 0.3,
	})
	if err != nil {
		return nil, err
	}

	// Parse AI response into structured quote
	return s.parseQuoteResponse(response)
}

// AnalyzeJobDescription analyzes a job description
func (s *LLMService) AnalyzeJobDescription(ctx context.Context, description string) (*JobAnalysis, error) {
	prompt := s.buildJobAnalysisPrompt(description)
	
	response, err := s.client.Generate(ctx, prompt, &llm.GenerateOptions{
		Model:       "gpt-4",
		MaxTokens:   1000,
		Temperature: 0.2,
	})
	if err != nil {
		return nil, err
	}

	return s.parseJobAnalysisResponse(response)
}

// PaymentService provides payment processing
type PaymentService struct {
	client *payments.Client
}

// ProcessPayment processes a payment
func (s *PaymentService) ProcessPayment(ctx context.Context, req *PaymentProcessRequest) (*domain.Payment, error) {
	paymentReq := &payments.PaymentRequest{
		Amount:       req.Amount,
		Currency:     "usd",
		PaymentMethod: req.PaymentMethod,
		PaymentToken: req.PaymentToken,
		CustomerID:   req.CustomerID.String(),
		Description:  req.Description,
	}

	result, err := s.client.ProcessPayment(ctx, paymentReq)
	if err != nil {
		return nil, err
	}

	// Convert to domain payment
	payment := &domain.Payment{
		ID:                   uuid.New(),
		TenantID:             uuid.New(), // This would come from context
		InvoiceID:            req.InvoiceID,
		Amount:               result.Amount,
		PaymentMethod:        result.PaymentMethod,
		PaymentGateway:       &result.Gateway,
		GatewayTransactionID: &result.TransactionID,
		Status:               result.Status,
		ProcessedAt:          &result.ProcessedAt,
		CreatedAt:            time.Now(),
		UpdatedAt:            time.Now(),
	}

	return payment, nil
}

// RefundPayment processes a refund
func (s *PaymentService) RefundPayment(ctx context.Context, paymentID uuid.UUID, amount float64) (*PaymentRefund, error) {
	refundReq := &payments.RefundRequest{
		PaymentID: paymentID.String(),
		Amount:    amount,
		Reason:    "requested_by_customer",
	}

	result, err := s.client.ProcessRefund(ctx, refundReq)
	if err != nil {
		return nil, err
	}

	refund := &PaymentRefund{
		RefundID:         result.RefundID,
		Amount:           result.Amount,
		Status:           result.Status,
		ProcessedAt:      result.ProcessedAt,
		RefundMethod:     result.RefundMethod,
		EstimatedArrival: result.EstimatedArrival,
	}

	return refund, nil
}

// HandleWebhook handles payment gateway webhooks
func (s *PaymentService) HandleWebhook(ctx context.Context, payload []byte, signature string) (*payments.WebhookEvent, error) {
	return s.client.HandleWebhook(ctx, payload, signature)
}

// CommunicationService provides communication operations
type CommunicationService struct {
	client *comms.Client
}

// SendEmail sends an email
func (s *CommunicationService) SendEmail(ctx context.Context, req *EmailRequest) error {
	emailReq := &comms.EmailRequest{
		To:          req.To,
		CC:          req.CC,
		BCC:         req.BCC,
		Subject:     req.Subject,
		Body:        req.Body,
		IsHTML:      req.IsHTML,
		Attachments: s.convertAttachments(req.Attachments),
	}

	return s.client.SendEmail(ctx, emailReq)
}

// SendSMS sends an SMS
func (s *CommunicationService) SendSMS(ctx context.Context, req *SMSRequest) error {
	smsReq := &comms.SMSRequest{
		To:      req.To,
		Message: req.Message,
	}

	return s.client.SendSMS(ctx, smsReq)
}

// SendTemplatedEmail sends a templated email
func (s *CommunicationService) SendTemplatedEmail(ctx context.Context, template string, data interface{}, to []string) error {
	return s.client.SendTemplatedEmail(ctx, template, data, to)
}

// External API interfaces and implementations

// WeatherAPI provides weather information
type WeatherAPI interface {
	GetCurrentWeather(ctx context.Context, lat, lng float64) (*WeatherData, error)
	GetWeatherForecast(ctx context.Context, lat, lng float64, days int) (*WeatherForecast, error)
	IsWeatherSuitable(ctx context.Context, lat, lng float64, jobType string) (bool, error)
}

// MapsAPI provides location and routing services
type MapsAPI interface {
	Geocode(ctx context.Context, address string) (*GeocodingResult, error)
	ReverseGeocode(ctx context.Context, lat, lng float64) (*GeocodingResult, error)
	CalculateRoute(ctx context.Context, origin, destination *Location) (*Route, error)
	OptimizeRoute(ctx context.Context, waypoints []*Location) (*OptimizedRoute, error)
	CalculateDistance(ctx context.Context, origin, destination *Location) (float64, error)
	GetTimezone(ctx context.Context, lat, lng float64) (string, error)
}

// CalendarAPI provides calendar integration
type CalendarAPI interface {
	CreateEvent(ctx context.Context, event *CalendarEvent) (*CalendarEvent, error)
	UpdateEvent(ctx context.Context, eventID string, event *CalendarEvent) (*CalendarEvent, error)
	DeleteEvent(ctx context.Context, eventID string) error
	GetEvents(ctx context.Context, startTime, endTime time.Time) ([]*CalendarEvent, error)
	SyncCalendar(ctx context.Context, userID uuid.UUID) error
}

// WebhookService manages webhooks
type WebhookService interface {
	TriggerWebhook(ctx context.Context, event string, data interface{}) error
	DeliverWebhook(ctx context.Context, webhook *domain.Webhook, event string, data interface{}) error
	RetryFailedDelivery(ctx context.Context, deliveryID uuid.UUID) error
}

// AuditService logs activities
type AuditService interface {
	LogIntegrationEvent(ctx context.Context, integration, event string, data interface{}) error
	LogAPICall(ctx context.Context, service, endpoint string, success bool, duration time.Duration) error
}

// Data structures for external APIs

type WeatherData struct {
	Temperature    float64 `json:"temperature"`
	Humidity       float64 `json:"humidity"`
	Conditions     string  `json:"conditions"`
	WindSpeed      float64 `json:"wind_speed"`
	Precipitation  float64 `json:"precipitation"`
	Visibility     float64 `json:"visibility"`
	UVIndex        float64 `json:"uv_index"`
	IsSuitable     bool    `json:"is_suitable"`
	Recommendation string  `json:"recommendation"`
}

type WeatherForecast struct {
	Days []WeatherForecastDay `json:"days"`
}

type WeatherForecastDay struct {
	Date    time.Time `json:"date"`
	High    float64   `json:"high"`
	Low     float64   `json:"low"`
	Weather WeatherData `json:"weather"`
}

type GeocodingResult struct {
	Address     string  `json:"address"`
	Latitude    float64 `json:"latitude"`
	Longitude   float64 `json:"longitude"`
	City        string  `json:"city"`
	State       string  `json:"state"`
	ZipCode     string  `json:"zip_code"`
	Country     string  `json:"country"`
	Timezone    string  `json:"timezone"`
}

type Route struct {
	Distance     float64      `json:"distance"`
	Duration     int          `json:"duration"`
	Steps        []RouteStep  `json:"steps"`
	Overview     string       `json:"overview"`
}

type RouteStep struct {
	Instruction string    `json:"instruction"`
	Distance    float64   `json:"distance"`
	Duration    int       `json:"duration"`
	StartLocation *Location `json:"start_location"`
	EndLocation   *Location `json:"end_location"`
}

type OptimizedRoute struct {
	Route
	OptimizedOrder []int     `json:"optimized_order"`
	TotalDistance  float64   `json:"total_distance"`
	TotalDuration  int       `json:"total_duration"`
	Savings        float64   `json:"savings_percent"`
}

type CalendarEvent struct {
	ID          string                 `json:"id,omitempty"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	StartTime   time.Time              `json:"start_time"`
	EndTime     time.Time              `json:"end_time"`
	Location    string                 `json:"location"`
	Attendees   []CalendarAttendee     `json:"attendees"`
	Reminders   []CalendarReminder     `json:"reminders"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type CalendarAttendee struct {
	Email string `json:"email"`
	Name  string `json:"name"`
	Role  string `json:"role"`
}

type CalendarReminder struct {
	Minutes int    `json:"minutes"`
	Method  string `json:"method"`
}

// Integration service implementations

// weatherAPI implements WeatherAPI
type weatherAPI struct {
	config *config.Config
}

func NewWeatherAPI(config *config.Config) WeatherAPI {
	return &weatherAPI{config: config}
}

func (w *weatherAPI) GetCurrentWeather(ctx context.Context, lat, lng float64) (*WeatherData, error) {
	// Implementation would call actual weather API
	// For now, return mock data
	return &WeatherData{
		Temperature:   75.0,
		Humidity:      60.0,
		Conditions:    "Clear",
		WindSpeed:     5.0,
		Precipitation: 0.0,
		Visibility:    10.0,
		UVIndex:       6.0,
		IsSuitable:    true,
		Recommendation: "Good conditions for landscaping work",
	}, nil
}

func (w *weatherAPI) GetWeatherForecast(ctx context.Context, lat, lng float64, days int) (*WeatherForecast, error) {
	// Implementation would call actual weather API
	return &WeatherForecast{
		Days: []WeatherForecastDay{
			{
				Date: time.Now().AddDate(0, 0, 1),
				High: 78.0,
				Low:  65.0,
				Weather: WeatherData{
					Temperature: 72.0,
					Conditions:  "Partly Cloudy",
					IsSuitable:  true,
				},
			},
		},
	}, nil
}

func (w *weatherAPI) IsWeatherSuitable(ctx context.Context, lat, lng float64, jobType string) (bool, error) {
	weather, err := w.GetCurrentWeather(ctx, lat, lng)
	if err != nil {
		return false, err
	}

	// Weather suitability logic based on job type
	switch jobType {
	case "mowing":
		return weather.Precipitation < 0.1 && weather.WindSpeed < 15, nil
	case "tree_service":
		return weather.WindSpeed < 20 && weather.Precipitation < 0.2, nil
	case "installation":
		return weather.Precipitation < 0.05, nil
	default:
		return weather.IsSuitable, nil
	}
}

// mapsAPI implements MapsAPI
type mapsAPI struct {
	config *config.Config
}

func NewMapsAPI(config *config.Config) MapsAPI {
	return &mapsAPI{config: config}
}

func (m *mapsAPI) Geocode(ctx context.Context, address string) (*GeocodingResult, error) {
	// Implementation would call actual maps API
	return &GeocodingResult{
		Address:   address,
		Latitude:  40.7128,
		Longitude: -74.0060,
		City:      "New York",
		State:     "NY",
		ZipCode:   "10001",
		Country:   "US",
		Timezone:  "America/New_York",
	}, nil
}

func (m *mapsAPI) ReverseGeocode(ctx context.Context, lat, lng float64) (*GeocodingResult, error) {
	// Implementation would call actual maps API
	return &GeocodingResult{
		Address:   "123 Main St, New York, NY 10001",
		Latitude:  lat,
		Longitude: lng,
		City:      "New York",
		State:     "NY",
		ZipCode:   "10001",
		Country:   "US",
		Timezone:  "America/New_York",
	}, nil
}

func (m *mapsAPI) CalculateRoute(ctx context.Context, origin, destination *Location) (*Route, error) {
	// Implementation would call actual maps API
	return &Route{
		Distance: 15.5,
		Duration: 25,
		Steps: []RouteStep{
			{
				Instruction:   "Head north on Main St",
				Distance:      0.5,
				Duration:      2,
				StartLocation: origin,
				EndLocation:   destination,
			},
		},
		Overview: "Route from origin to destination",
	}, nil
}

func (m *mapsAPI) OptimizeRoute(ctx context.Context, waypoints []*Location) (*OptimizedRoute, error) {
	// Implementation would call actual route optimization API
	return &OptimizedRoute{
		Route: Route{
			Distance: 25.0,
			Duration: 45,
		},
		OptimizedOrder: []int{0, 2, 1, 3},
		TotalDistance:  25.0,
		TotalDuration:  45,
		Savings:        15.5,
	}, nil
}

func (m *mapsAPI) CalculateDistance(ctx context.Context, origin, destination *Location) (float64, error) {
	// Implementation would calculate distance
	return 10.5, nil
}

func (m *mapsAPI) GetTimezone(ctx context.Context, lat, lng float64) (string, error) {
	// Implementation would call timezone API
	return "America/New_York", nil
}

// calendarAPI implements CalendarAPI
type calendarAPI struct {
	config *config.Config
}

func NewCalendarAPI(config *config.Config) CalendarAPI {
	return &calendarAPI{config: config}
}

func (c *calendarAPI) CreateEvent(ctx context.Context, event *CalendarEvent) (*CalendarEvent, error) {
	// Implementation would call calendar API (Google Calendar, Outlook, etc.)
	event.ID = uuid.New().String()
	return event, nil
}

func (c *calendarAPI) UpdateEvent(ctx context.Context, eventID string, event *CalendarEvent) (*CalendarEvent, error) {
	// Implementation would call calendar API
	event.ID = eventID
	return event, nil
}

func (c *calendarAPI) DeleteEvent(ctx context.Context, eventID string) error {
	// Implementation would call calendar API
	return nil
}

func (c *calendarAPI) GetEvents(ctx context.Context, startTime, endTime time.Time) ([]*CalendarEvent, error) {
	// Implementation would call calendar API
	return []*CalendarEvent{}, nil
}

func (c *calendarAPI) SyncCalendar(ctx context.Context, userID uuid.UUID) error {
	// Implementation would sync with external calendar
	return nil
}

// Helper methods for LLM service

func (s *LLMService) buildQuotePrompt(req *QuoteGenerationRequest) string {
	// Build a comprehensive prompt for quote generation
	prompt := `You are a professional landscaping estimator. Generate a detailed quote based on the following information:

Customer Description: ` + req.Description + `

Requirements: ` + joinStrings(req.Requirements, ", ") + `

Please provide:
1. Recommended services with quantities and pricing
2. Estimated timeline
3. Any special considerations
4. Confidence level (0-1)

Format your response as JSON with the following structure:
{
  "recommended_services": [
    {
      "service_name": "string",
      "quantity": number,
      "unit_price": number,
      "total_price": number,
      "reasoning": "string"
    }
  ],
  "estimated_total": number,
  "timeline_estimate": "string",
  "notes": "string",
  "confidence": number
}`

	if req.Budget != nil {
		prompt += "\n\nBudget: $" + formatFloat(*req.Budget)
	}

	if req.Timeline != nil {
		prompt += "\n\nTimeline: " + *req.Timeline
	}

	return prompt
}

func (s *LLMService) buildJobAnalysisPrompt(description string) string {
	return `Analyze this landscaping job description and provide structured information:

Job Description: ` + description + `

Please analyze and provide:
1. Estimated duration in minutes
2. Required services/tasks
3. Complexity level (low, medium, high)
4. Required skills
5. Required equipment
6. Weather dependency (true/false)
7. Seasonality considerations

Format as JSON:
{
  "estimated_duration": number,
  "required_services": ["string"],
  "complexity": "string",
  "required_skills": ["string"],
  "required_equipment": ["string"],
  "weather_dependency": boolean,
  "seasonality": "string"
}`
}

func (s *LLMService) parseQuoteResponse(response string) (*QuoteGenerationResponse, error) {
	// Parse AI response into structured quote
	// This would use JSON parsing in real implementation
	return &QuoteGenerationResponse{
		RecommendedServices: []ServiceRecommendation{
			{
				ServiceID:   uuid.New(),
				ServiceName: "Lawn Mowing",
				Quantity:    1.0,
				UnitPrice:   50.0,
				TotalPrice:  50.0,
				Reasoning:   "Standard residential lawn maintenance",
			},
		},
		EstimatedTotal:   250.0,
		TimelineEstimate: "2-3 hours",
		Notes:           "Weather permitting, can complete same day",
		Confidence:      0.85,
	}, nil
}

func (s *LLMService) parseJobAnalysisResponse(response string) (*JobAnalysis, error) {
	// Parse AI response into structured job analysis
	return &JobAnalysis{
		EstimatedDuration: 120,
		RequiredServices:  []string{"mowing", "edging", "cleanup"},
		Complexity:        "medium",
		RequiredSkills:    []string{"lawn_care", "equipment_operation"},
		RequiredEquipment: []string{"mower", "edger", "blower"},
		WeatherDependency: true,
		Seasonality:       "spring_summer_fall",
	}, nil
}

func (s *CommunicationService) convertAttachments(attachments []Attachment) []comms.Attachment {
	var commsAttachments []comms.Attachment
	for _, att := range attachments {
		commsAttachments = append(commsAttachments, comms.Attachment{
			Name:        att.Name,
			ContentType: att.ContentType,
			Data:        att.Data,
		})
	}
	return commsAttachments
}

// Utility functions
func joinStrings(strs []string, separator string) string {
	if len(strs) == 0 {
		return ""
	}
	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += separator + strs[i]
	}
	return result
}

func formatFloat(f float64) string {
	return fmt.Sprintf("%.2f", f)
}

// TODO: Import types from specific integration files to avoid duplication


type LLMOptions struct {
	Model       string  `json:"model"`
	MaxTokens   int     `json:"max_tokens"`
	Temperature float64 `json:"temperature"`
}

type Location struct {
	Latitude  float64 `json:"latitude"`
	Longitude float64 `json:"longitude"`
	Address   string  `json:"address"`
}