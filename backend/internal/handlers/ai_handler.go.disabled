package handlers

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"net/http"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/gorilla/websocket"

	"github.com/pageza/landscaping-app/backend/internal/ai"
	"github.com/pageza/landscaping-app/backend/internal/config"
	"github.com/pageza/landscaping-app/backend/internal/middleware"
	"github.com/pageza/landscaping-app/backend/internal/services"
)

// AIHandler handles AI assistant HTTP and WebSocket requests
type AIHandler struct {
	assistant ai.Assistant
	config    *config.Config
	services  *services.Services
	logger    *slog.Logger
	upgrader  websocket.Upgrader
}

// NewAIHandler creates a new AI handler
func NewAIHandler(assistant ai.Assistant, config *config.Config, services *services.Services, logger *slog.Logger) *AIHandler {
	return &AIHandler{
		assistant: assistant,
		config:    config,
		services:  services,
		logger:    logger,
		upgrader: websocket.Upgrader{
			ReadBufferSize:  1024,
			WriteBufferSize: 1024,
			CheckOrigin: func(r *http.Request) bool {
				// In production, implement proper origin checking
				return true
			},
		},
	}
}

// SetupRoutes configures AI assistant routes
func (h *AIHandler) SetupRoutes(r *mux.Router, mw *middleware.EnhancedMiddleware) {
	// AI assistant routes
	ai := r.PathPrefix("/ai").Subrouter()
	ai.Use(mw.JWTAuth)
	ai.Use(mw.TenantContext)

	// Chat endpoints
	ai.HandleFunc("/chat", h.Chat).Methods("POST")
	ai.HandleFunc("/conversations", h.ListConversations).Methods("GET")
	ai.HandleFunc("/conversations", h.StartConversation).Methods("POST")
	ai.HandleFunc("/conversations/{conversationId}", h.GetConversation).Methods("GET")
	ai.HandleFunc("/conversations/{conversationId}", h.EndConversation).Methods("DELETE")
	ai.HandleFunc("/conversations/{conversationId}/messages", h.GetMessages).Methods("GET")
	ai.HandleFunc("/conversations/{conversationId}/summary", h.GetConversationSummary).Methods("GET")

	// WebSocket chat endpoint
	ai.HandleFunc("/chat/ws", h.ChatWebSocket).Methods("GET")

	// Configuration endpoints (admin only)
	aiAdmin := ai.PathPrefix("/admin").Subrouter()
	aiAdmin.Use(mw.RequireRole("admin", "owner"))
	aiAdmin.HandleFunc("/config", h.GetConfig).Methods("GET")
	aiAdmin.HandleFunc("/config", h.UpdateConfig).Methods("PUT")
	aiAdmin.HandleFunc("/metrics", h.GetMetrics).Methods("GET")
	aiAdmin.HandleFunc("/functions", h.ListFunctions).Methods("GET")
	aiAdmin.HandleFunc("/functions/{functionName}", h.ToggleFunction).Methods("PUT")

	// Usage and monitoring endpoints
	aiUsage := ai.PathPrefix("/usage").Subrouter()
	aiUsage.HandleFunc("/stats", h.GetUsageStats).Methods("GET")
	aiUsage.HandleFunc("/limits", h.GetRateLimits).Methods("GET")
}

// Chat handles synchronous chat requests
func (h *AIHandler) Chat(w http.ResponseWriter, r *http.Request) {
	var req ai.ChatRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid request body", err)
		return
	}

	// Validate request
	if req.Message == "" {
		h.writeError(w, http.StatusBadRequest, "Message is required", nil)
		return
	}

	// Add user context to request context
	ctx := h.addUserContextToRequest(r)

	// Process chat request
	response, err := h.assistant.Chat(ctx, &req)
	if err != nil {
		h.logger.Error("Chat request failed", "error", err)
		
		// Check if it's a rate limit error
		if rateLimitErr, ok := err.(*ai.RateLimitError); ok {
			h.writeRateLimitError(w, rateLimitErr)
			return
		}
		
		h.writeError(w, http.StatusInternalServerError, "Chat request failed", err)
		return
	}

	h.writeJSON(w, http.StatusOK, response)
}

// ListConversations lists conversations for the current user
func (h *AIHandler) ListConversations(w http.ResponseWriter, r *http.Request) {
	ctx := h.addUserContextToRequest(r)
	
	// Parse query parameters
	filter := &ai.ConversationFilter{
		Limit:  20,
		Offset: 0,
	}

	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		if limit, err := strconv.Atoi(limitStr); err == nil && limit > 0 && limit <= 100 {
			filter.Limit = limit
		}
	}

	if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" {
		if offset, err := strconv.Atoi(offsetStr); err == nil && offset >= 0 {
			filter.Offset = offset
		}
	}

	// Add user/tenant filters
	userID := h.getUserIDFromContext(ctx)
	tenantID := h.getTenantIDFromContext(ctx)
	
	filter.UserID = userID
	filter.TenantID = &tenantID

	// Parse assistant type filter
	if assistantType := r.URL.Query().Get("type"); assistantType != "" {
		aType := ai.AssistantType(assistantType)
		filter.AssistantType = &aType
	}

	// Parse date filters
	if startDate := r.URL.Query().Get("start_date"); startDate != "" {
		if date, err := time.Parse("2006-01-02", startDate); err == nil {
			filter.StartDate = &date
		}
	}

	if endDate := r.URL.Query().Get("end_date"); endDate != "" {
		if date, err := time.Parse("2006-01-02", endDate); err == nil {
			filter.EndDate = &date
		}
	}

	// Get conversations from context store
	conversations, err := h.assistant.(*ai.AIAssistant).GetConversationStore().GetConversations(ctx, filter)
	if err != nil {
		h.logger.Error("Failed to get conversations", "error", err)
		h.writeError(w, http.StatusInternalServerError, "Failed to get conversations", err)
		return
	}

	response := map[string]interface{}{
		"conversations": conversations,
		"limit":        filter.Limit,
		"offset":       filter.Offset,
		"total":        len(conversations),
	}

	h.writeJSON(w, http.StatusOK, response)
}

// StartConversation starts a new conversation
func (h *AIHandler) StartConversation(w http.ResponseWriter, r *http.Request) {
	var req struct {
		AssistantType ai.AssistantType `json:"assistant_type"`
		CustomerID    *uuid.UUID       `json:"customer_id,omitempty"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid request body", err)
		return
	}

	// Validate assistant type
	if req.AssistantType != ai.CustomerAssistant && req.AssistantType != ai.BusinessAssistant {
		h.writeError(w, http.StatusBadRequest, "Invalid assistant type", nil)
		return
	}

	ctx := h.addUserContextToRequest(r)
	userID := h.getUserIDFromContext(ctx)

	// Start conversation
	conversation, err := h.assistant.StartConversation(ctx, req.AssistantType, userID, req.CustomerID)
	if err != nil {
		h.logger.Error("Failed to start conversation", "error", err)
		h.writeError(w, http.StatusInternalServerError, "Failed to start conversation", err)
		return
	}

	h.writeJSON(w, http.StatusCreated, conversation)
}

// GetConversation gets a specific conversation
func (h *AIHandler) GetConversation(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	conversationID, err := uuid.Parse(vars["conversationId"])
	if err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid conversation ID", err)
		return
	}

	ctx := h.addUserContextToRequest(r)

	conversation, err := h.assistant.GetConversation(ctx, conversationID)
	if err != nil {
		h.logger.Error("Failed to get conversation", "error", err, "conversation_id", conversationID)
		h.writeError(w, http.StatusNotFound, "Conversation not found", err)
		return
	}

	// Verify user has access to this conversation
	userID := h.getUserIDFromContext(ctx)
	if conversation.UserID != nil && userID != nil && *conversation.UserID != *userID {
		h.writeError(w, http.StatusForbidden, "Access denied", nil)
		return
	}

	h.writeJSON(w, http.StatusOK, conversation)
}

// EndConversation ends a conversation
func (h *AIHandler) EndConversation(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	conversationID, err := uuid.Parse(vars["conversationId"])
	if err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid conversation ID", err)
		return
	}

	ctx := h.addUserContextToRequest(r)

	// Verify user has access to this conversation
	conversation, err := h.assistant.GetConversation(ctx, conversationID)
	if err != nil {
		h.writeError(w, http.StatusNotFound, "Conversation not found", err)
		return
	}

	userID := h.getUserIDFromContext(ctx)
	if conversation.UserID != nil && userID != nil && *conversation.UserID != *userID {
		h.writeError(w, http.StatusForbidden, "Access denied", nil)
		return
	}

	// End conversation
	if err := h.assistant.EndConversation(ctx, conversationID); err != nil {
		h.logger.Error("Failed to end conversation", "error", err, "conversation_id", conversationID)
		h.writeError(w, http.StatusInternalServerError, "Failed to end conversation", err)
		return
	}

	h.writeJSON(w, http.StatusOK, map[string]string{"message": "Conversation ended successfully"})
}

// GetMessages gets messages for a conversation
func (h *AIHandler) GetMessages(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	conversationID, err := uuid.Parse(vars["conversationId"])
	if err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid conversation ID", err)
		return
	}

	// Parse pagination parameters
	limit := 20
	offset := 0

	if limitStr := r.URL.Query().Get("limit"); limitStr != "" {
		if l, err := strconv.Atoi(limitStr); err == nil && l > 0 && l <= 100 {
			limit = l
		}
	}

	if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" {
		if o, err := strconv.Atoi(offsetStr); err == nil && o >= 0 {
			offset = o
		}
	}

	ctx := h.addUserContextToRequest(r)

	// Verify user has access to this conversation
	conversation, err := h.assistant.GetConversation(ctx, conversationID)
	if err != nil {
		h.writeError(w, http.StatusNotFound, "Conversation not found", err)
		return
	}

	userID := h.getUserIDFromContext(ctx)
	if conversation.UserID != nil && userID != nil && *conversation.UserID != *userID {
		h.writeError(w, http.StatusForbidden, "Access denied", nil)
		return
	}

	// Get messages
	messages, err := h.assistant.GetMessages(ctx, conversationID, limit, offset)
	if err != nil {
		h.logger.Error("Failed to get messages", "error", err, "conversation_id", conversationID)
		h.writeError(w, http.StatusInternalServerError, "Failed to get messages", err)
		return
	}

	response := map[string]interface{}{
		"messages": messages,
		"limit":    limit,
		"offset":   offset,
		"total":    len(messages),
	}

	h.writeJSON(w, http.StatusOK, response)
}

// GetConversationSummary gets a conversation summary
func (h *AIHandler) GetConversationSummary(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	conversationID, err := uuid.Parse(vars["conversationId"])
	if err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid conversation ID", err)
		return
	}

	ctx := h.addUserContextToRequest(r)

	// Verify user has access to this conversation
	conversation, err := h.assistant.GetConversation(ctx, conversationID)
	if err != nil {
		h.writeError(w, http.StatusNotFound, "Conversation not found", err)
		return
	}

	userID := h.getUserIDFromContext(ctx)
	if conversation.UserID != nil && userID != nil && *conversation.UserID != *userID {
		h.writeError(w, http.StatusForbidden, "Access denied", nil)
		return
	}

	// Get conversation summary
	summary, err := h.assistant.GetConversationSummary(ctx, conversationID)
	if err != nil {
		h.logger.Error("Failed to get conversation summary", "error", err, "conversation_id", conversationID)
		h.writeError(w, http.StatusInternalServerError, "Failed to get conversation summary", err)
		return
	}

	h.writeJSON(w, http.StatusOK, summary)
}

// ChatWebSocket handles WebSocket chat connections
func (h *AIHandler) ChatWebSocket(w http.ResponseWriter, r *http.Request) {
	// Upgrade connection to WebSocket
	conn, err := h.upgrader.Upgrade(w, r, nil)
	if err != nil {
		h.logger.Error("Failed to upgrade WebSocket connection", "error", err)
		return
	}
	defer conn.Close()

	ctx := h.addUserContextToRequest(r)
	userID := h.getUserIDFromContext(ctx)
	tenantID := h.getTenantIDFromContext(ctx)

	h.logger.Info("WebSocket connection established", "user_id", userID, "tenant_id", tenantID)

	// Send connected message
	connectedMsg := ai.WebSocketMessage{
		Type: string(ai.MessageTypeConnected),
		Payload: map[string]interface{}{
			"message": "Connected to AI assistant",
			"user_id": userID,
		},
	}
	
	if err := conn.WriteJSON(connectedMsg); err != nil {
		h.logger.Error("Failed to send connected message", "error", err)
		return
	}

	// Handle WebSocket messages
	for {
		var wsMsg ai.WebSocketMessage
		if err := conn.ReadJSON(&wsMsg); err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				h.logger.Error("WebSocket read error", "error", err)
			}
			break
		}

		// Process message based on type
		switch ai.WebSocketMessageType(wsMsg.Type) {
		case ai.MessageTypeChat:
			h.handleWebSocketChat(ctx, conn, wsMsg)
		case ai.MessageTypeTyping:
			// Handle typing indicator (could relay to other participants)
			h.logger.Debug("User typing", "user_id", userID)
		default:
			h.logger.Warn("Unknown WebSocket message type", "type", wsMsg.Type)
		}
	}

	h.logger.Info("WebSocket connection closed", "user_id", userID)
}

// handleWebSocketChat processes chat messages over WebSocket
func (h *AIHandler) handleWebSocketChat(ctx context.Context, conn *websocket.Conn, wsMsg ai.WebSocketMessage) {
	// Parse chat request from WebSocket message
	payloadBytes, err := json.Marshal(wsMsg.Payload)
	if err != nil {
		h.sendWebSocketError(conn, "Invalid message payload")
		return
	}

	var chatReq ai.ChatRequest
	if err := json.Unmarshal(payloadBytes, &chatReq); err != nil {
		h.sendWebSocketError(conn, "Invalid chat request")
		return
	}

	if chatReq.Message == "" {
		h.sendWebSocketError(conn, "Message is required")
		return
	}

	// Process chat request
	response, err := h.assistant.Chat(ctx, &chatReq)
	if err != nil {
		h.logger.Error("WebSocket chat request failed", "error", err)
		
		if rateLimitErr, ok := err.(*ai.RateLimitError); ok {
			h.sendWebSocketError(conn, fmt.Sprintf("Rate limit exceeded: %s", rateLimitErr.Message))
			return
		}
		
		h.sendWebSocketError(conn, "Chat request failed")
		return
	}

	// Send response back over WebSocket
	responseMsg := ai.WebSocketMessage{
		Type:    string(ai.MessageTypeChat),
		Payload: response,
	}

	if err := conn.WriteJSON(responseMsg); err != nil {
		h.logger.Error("Failed to send WebSocket response", "error", err)
	}
}

// sendWebSocketError sends an error message over WebSocket
func (h *AIHandler) sendWebSocketError(conn *websocket.Conn, message string) {
	errorMsg := ai.WebSocketMessage{
		Type: string(ai.MessageTypeError),
		Payload: map[string]interface{}{
			"error":   message,
			"timestamp": time.Now(),
		},
	}

	if err := conn.WriteJSON(errorMsg); err != nil {
		h.logger.Error("Failed to send WebSocket error", "error", err)
	}
}

// Admin endpoints

// GetConfig gets the current AI assistant configuration
func (h *AIHandler) GetConfig(w http.ResponseWriter, r *http.Request) {
	config := h.assistant.GetConfig()
	h.writeJSON(w, http.StatusOK, config)
}

// UpdateConfig updates the AI assistant configuration
func (h *AIHandler) UpdateConfig(w http.ResponseWriter, r *http.Request) {
	var config ai.AssistantConfig
	if err := json.NewDecoder(r.Body).Decode(&config); err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid configuration", err)
		return
	}

	if err := h.assistant.UpdateConfig(&config); err != nil {
		h.logger.Error("Failed to update AI configuration", "error", err)
		h.writeError(w, http.StatusInternalServerError, "Failed to update configuration", err)
		return
	}

	h.writeJSON(w, http.StatusOK, map[string]string{"message": "Configuration updated successfully"})
}

// GetMetrics gets AI usage metrics
func (h *AIHandler) GetMetrics(w http.ResponseWriter, r *http.Request) {
	ctx := h.addUserContextToRequest(r)
	tenantID := h.getTenantIDFromContext(ctx)

	// Parse date range
	now := time.Now()
	startDate := now.AddDate(0, -1, 0) // Default to last month
	endDate := now

	if startStr := r.URL.Query().Get("start_date"); startStr != "" {
		if date, err := time.Parse("2006-01-02", startStr); err == nil {
			startDate = date
		}
	}

	if endStr := r.URL.Query().Get("end_date"); endStr != "" {
		if date, err := time.Parse("2006-01-02", endStr); err == nil {
			endDate = date
		}
	}

	metrics, err := h.assistant.GetMetrics(ctx, tenantID, startDate, endDate)
	if err != nil {
		h.logger.Error("Failed to get AI metrics", "error", err)
		h.writeError(w, http.StatusInternalServerError, "Failed to get metrics", err)
		return
	}

	h.writeJSON(w, http.StatusOK, metrics)
}

// ListFunctions lists available AI functions
func (h *AIHandler) ListFunctions(w http.ResponseWriter, r *http.Request) {
	assistantType := ai.CustomerAssistant
	if typeParam := r.URL.Query().Get("type"); typeParam != "" {
		assistantType = ai.AssistantType(typeParam)
	}

	functions := h.assistant.GetAvailableFunctions(assistantType)
	
	response := map[string]interface{}{
		"assistant_type": assistantType,
		"functions":      functions,
		"total":          len(functions),
	}

	h.writeJSON(w, http.StatusOK, response)
}

// ToggleFunction enables/disables a specific function
func (h *AIHandler) ToggleFunction(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	functionName := vars["functionName"]

	var req struct {
		Enabled bool `json:"enabled"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.writeError(w, http.StatusBadRequest, "Invalid request body", err)
		return
	}

	// This would require extending the Assistant interface to support enabling/disabling functions
	// For now, return a success message
	message := "enabled"
	if !req.Enabled {
		message = "disabled"
	}

	response := map[string]interface{}{
		"function": functionName,
		"enabled":  req.Enabled,
		"message":  fmt.Sprintf("Function %s %s successfully", functionName, message),
	}

	h.writeJSON(w, http.StatusOK, response)
}

// Usage and monitoring endpoints

// GetUsageStats gets usage statistics for the current user/tenant
func (h *AIHandler) GetUsageStats(w http.ResponseWriter, r *http.Request) {
	ctx := h.addUserContextToRequest(r)
	userID := h.getUserIDFromContext(ctx)
	tenantID := h.getTenantIDFromContext(ctx)

	// This would require implementing a rate limiter interface method
	// For now, return mock data
	stats := &ai.UsageStats{
		RequestsPerMinute: 5,
		RequestsPerHour:   50,
		RequestsPerDay:    200,
		TokensPerMinute:   1500,
		TokensPerHour:     15000,
		TokensPerDay:      60000,
		CostPerDay:        6.00,
		LastRequest:       time.Now().Add(-5 * time.Minute),
		IsBlocked:         false,
	}

	h.logger.Info("Retrieved usage stats", "user_id", userID, "tenant_id", tenantID)
	h.writeJSON(w, http.StatusOK, stats)
}

// GetRateLimits gets current rate limit configuration
func (h *AIHandler) GetRateLimits(w http.ResponseWriter, r *http.Request) {
	config := h.assistant.GetConfig()
	
	limits := map[string]interface{}{
		"requests_per_minute": config.RateLimit.RequestsPerMinute,
		"requests_per_hour":   config.RateLimit.RequestsPerHour,
		"requests_per_day":    config.RateLimit.RequestsPerDay,
		"tokens_per_minute":   config.RateLimit.TokensPerMinute,
		"tokens_per_hour":     config.RateLimit.TokensPerHour,
		"tokens_per_day":      config.RateLimit.TokensPerDay,
		"cost_limit_per_day":  config.RateLimit.CostLimitPerDay,
		"enabled":             config.RateLimit.Enabled,
	}

	h.writeJSON(w, http.StatusOK, limits)
}

// Helper methods

func (h *AIHandler) addUserContextToRequest(r *http.Request) context.Context {
	ctx := r.Context()
	
	// Extract user and tenant information from JWT claims or middleware
	// This would typically be set by authentication middleware
	
	return ctx
}

func (h *AIHandler) getUserIDFromContext(ctx context.Context) *uuid.UUID {
	// Extract user ID from context
	// This would be set by authentication middleware
	return nil // Placeholder
}

func (h *AIHandler) getTenantIDFromContext(ctx context.Context) uuid.UUID {
	// Extract tenant ID from context
	// This would be set by tenant middleware
	return uuid.New() // Placeholder
}

func (h *AIHandler) writeJSON(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	
	if err := json.NewEncoder(w).Encode(data); err != nil {
		h.logger.Error("Failed to encode JSON response", "error", err)
	}
}

func (h *AIHandler) writeError(w http.ResponseWriter, status int, message string, err error) {
	response := map[string]interface{}{
		"error":     message,
		"timestamp": time.Now(),
	}
	
	if h.config.Debug && err != nil {
		response["details"] = err.Error()
	}
	
	h.writeJSON(w, status, response)
}

func (h *AIHandler) writeRateLimitError(w http.ResponseWriter, rateLimitErr *ai.RateLimitError) {
	w.Header().Set("Retry-After", strconv.Itoa(int(time.Until(rateLimitErr.RetryAfter).Seconds())))
	
	response := map[string]interface{}{
		"error":        rateLimitErr.Message,
		"limit_type":   rateLimitErr.LimitType,
		"retry_after":  rateLimitErr.RetryAfter,
		"timestamp":    time.Now(),
	}
	
	h.writeJSON(w, http.StatusTooManyRequests, response)
}